package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"

	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/google/go-github/v32/github"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
	"golang.org/x/oauth2"

	resty "github.com/go-resty/resty/v2"
	yaml "gopkg.in/yaml.v2"
)

func main() {
	// cleanup()
	driver := setupNeo4j()
	defer driver.Close()

	session := driver.NewSession(neo4j.SessionConfig{})
	defer session.Close()

	client := setupGitHub()

	repos := fetchRepositories(client)

	processRepositories(session, client, repos)

	interactWithChatGPT(session, driver)
}

func setupNeo4j() neo4j.Driver {
	neo4jURI, neo4jUser, neo4jPassword := getNeo4jEnvVars()
	driver, err := neo4j.NewDriver(neo4jURI, neo4j.BasicAuth(neo4jUser, neo4jPassword, ""))
	if err != nil {
		panic(err)
	}
	return driver
}

func getNeo4jEnvVars() (string, string, string) {
	neo4jURI := os.Getenv("NEO4J_URI")
	neo4jUser := os.Getenv("NEO4J_USER")
	neo4jPassword := os.Getenv("NEO4J_PASSWORD")
	return neo4jURI, neo4jUser, neo4jPassword
}

func setupGitHub() *github.Client {
	ctx := context.Background()
	ts := oauth2.StaticTokenSource(
		&oauth2.Token{AccessToken: os.Getenv("GITHUB_TOKEN")},
	)
	tc := oauth2.NewClient(ctx, ts)
	client := github.NewClient(tc)
	return client
}

func fetchRepositories(client *github.Client) []*github.Repository {
	ctx := context.Background()
	opt := &github.RepositoryListByOrgOptions{Type: "public"}
	repos, _, err := client.Repositories.ListByOrg(ctx, "kubernetes", opt)
	if err != nil {
		fmt.Println("Error:", err)
		panic(err)
	}
	return repos
}

func processRepositories(session neo4j.Session, client *github.Client, repos []*github.Repository) {

	for i, repo := range repos {
		if *repo.Name != "dashboard" && *repo.Name != "website" && *repo.Name != "community" {
			continue
		}
		processRepository(session, repo)
		if i >= 4 {
			break
		}
	}
}

func processRepository(session neo4j.Session, repo *github.Repository) {
	// Clone the repository
	err := gitCloneRepo(*repo.CloneURL, *repo.Name)
	if err != nil {
		fmt.Println("Error:", err)
	}
	repoPath := filepath.Join("./code", *repo.Name)
	// fmt.Println(repoPath)
	// Run gosec on the cloned repository
	vulnerabilities, err := runGosec(repoPath)
	if err != nil {
		fmt.Println("Error running gosec:", err)
		return
	}
	gosecOutput, err := parseGosecOutput(vulnerabilities)
	if err != nil {
		fmt.Println("Error parsing gosec output:", err)
	}
	// fmt.Println("Vulnerabilities:", len(gosecOutput.Issues), vulnerabilities)
	for k, issue := range gosecOutput.Issues {
		lineNos := strings.Split(issue.Line, "-")
		lineNo, err := strconv.Atoi(lineNos[0])
		if err != nil {
			fmt.Println("Error:", err)
			continue
		}
		author, err := findLineAuthor(repoPath, issue.File, lineNo)
		if err != nil {
			fmt.Println("Error finding author:", err)
			continue
		}
		gosecOutput.Issues[k].Author = author
	}
	approvers, err := readApprovers(repoPath)
	if err != nil {
		fmt.Println("Error reading OWNERS file:", err)
	}
	// Use the first approver as the owner (or modify as needed)
	ownerName := ""
	if len(approvers) > 0 {
		ownerName = approvers[0]
	} else {
		ownerName = *repo.Owner.Login
	}
	// fmt.Println("ownerName", ownerName)
	// Store repository information and vulnerabilities in Neo4j
	// storeInNeo4j(session, *repo.Name, *repo.Owner.Login, vulnerabilities)
	_, err = session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		cypher := `
			MERGE (r:Repository {name: $repoName})
			MERGE (o:Owner {name: $ownerName})
			MERGE (r)-[:OWNED_BY]->(o)
			FOREACH (issue IN $issues | 
					MERGE (v:Vulnerability {ruleID: issue.RuleID})
					ON CREATE SET v.severity = issue.Severity, v.details = issue.Details, v.file = issue.File, v.line = issue.Line
					MERGE (a:Author {name: issue.Author})
					MERGE (v)-[:AUTHORED_BY]->(a)
					MERGE (r)-[:HAS_VULNERABILITY]->(v)
					SET v.author = issue.Author
					SET v.repoName = $repoName
					SET v.ownerName = $ownerName
			)
			`
		issues := []map[string]interface{}{}
		for _, issue := range gosecOutput.Issues {
			issues = append(issues, map[string]interface{}{
				"Severity":   issue.Severity,
				"Confidence": issue.Confidence,
				"RuleID":     issue.RuleID,
				"Details":    issue.Details,
				"File":       issue.File,
				"Line":       issue.Line,
				"Author":     issue.Author,
				"RepoName":   *repo.Name,
				"OwnerName":  ownerName,
			})
		}

		params := map[string]interface{}{
			"repoName":  *repo.Name,
			"ownerName": ownerName, // Use the ownerName from the OWNERS file
			"issues":    issues,
		}
		return tx.Run(cypher, params)
	})

	if err != nil {
		fmt.Println("Error storing data in Neo4j:", err)
	} else {
		fmt.Printf("Added repository %s with vulnerabilities to Neo4j\n", *repo.Name)
	}
}

func interactWithChatGPT(session neo4j.Session, driver neo4j.Driver) {
	query := `
		MATCH (v:Vulnerability)
		RETURN v
	`

	// Fetch data
	result, err := session.Run(query, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Process results
	var records []map[string]interface{}
	for result.Next() {
		record := result.Record()
		if node, ok := record.GetByIndex(0).(neo4j.Node); ok {
			records = append(records, node.Props)
		}
	}

	if err := result.Err(); err != nil {
		log.Fatal(err)
	}

	// Convert to JSON
	jsonData, err := json.Marshal(records)
	if err != nil {
		log.Fatal(err)
	}

	// fmt.Println("data", string(jsonData))

	//chat gpt
	apiKey := os.Getenv("OPENAI_API_KEY")
	aiClient := resty.New()
	apiEndpoint := "https://api.openai.com/v1/chat/completions"

	var conversation []map[string]interface{}

	// for {
	fmt.Println("With data ", string(jsonData))
	userInput := "tell me the first issue to be fixed based. who is the owner and author of this repository? can you suggest some examples?"
	prompt := `With this data from gosec scanning and identifying vulenrabilities in different repositories: ` + string(jsonData) + `.` +
		userInput
	// Append user's message to the conversation
	conversation = append(conversation, map[string]interface{}{"role": "system", "content": prompt})

	// Send the conversation to the AI model
	response := sendMessage(aiClient, apiKey, apiEndpoint, conversation)

	// Extract and display the AI's response
	content := extractContent(response)
	fmt.Println("AI: " + content)
}

// func getUserInput() string {
// 	var userInput string
// 	fmt.Println("Enter your message:")
// 	fmt.Scanln(&userInput)
// 	return userInput
// }

func sendMessage(client *resty.Client, apiKey, endpoint string, conversation []map[string]interface{}) *resty.Response {
	response, err := client.R().
		SetAuthToken(apiKey).
		SetHeader("Content-Type", "application/json").
		SetBody(map[string]interface{}{
			"model":      "gpt-4",
			"messages":   conversation,
			"max_tokens": 50,
		}).
		Post(endpoint)

	if err != nil {
		log.Fatalf("Error while sending send the request: %v", err)
	}

	return response
}

func extractContent(response *resty.Response) string {
	body := response.Body()

	var data map[string]interface{}
	err := json.Unmarshal(body, &data)
	if err != nil {
		fmt.Println("Error while decoding JSON response:", err)
		return ""
	}

	content := data["choices"].([]interface{})[0].(map[string]interface{})["message"].(map[string]interface{})["content"].(string)
	return content
}

// func cleanup() {
// 	// Delete the code directory
// 	err := os.RemoveAll("./code/")
// 	if err != nil {
// 		fmt.Println("Error:", err)
// 	}
// 	fmt.Println("Deleted code directory")
// }

// gitCloneRepo clones a Git repository from the provided URL into the current directory.
func gitCloneRepo(repoURL, repoName string) error {
	// Construct the path to clone the repository
	clonePath := filepath.Join("./code", repoName)

	// Check if the directory already exists
	if _, err := os.Stat(clonePath); !os.IsNotExist(err) {
		return fmt.Errorf("directory already exists: %s", clonePath)
	}

	// Execute the git clone command
	cmd := exec.Command("git", "clone", repoURL, clonePath)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err := cmd.Run()
	if err != nil {
		return fmt.Errorf("failed to clone repository: %v", err)
	}

	fmt.Printf("Repository cloned successfully: %s\n", clonePath)
	return nil
}

// runGosec runs gosec on the provided directory and returns the results.
func runGosec(repoPath string) (string, error) {
	fmt.Println("Running gosec...")

	// Define the path for the gosec output file
	gosecOutputFile := filepath.Join(repoPath, "gosec_output.json")

	// Execute gosec and redirect its output to the specified file
	cmd := exec.Command("gosec", "-fmt=json", "./...")
	cmd.Dir = repoPath
	outputFile, err := os.Create(gosecOutputFile)
	if err != nil {
		return "", fmt.Errorf("failed to create gosec output file: %w", err)
	}
	defer outputFile.Close()
	cmd.Stdout = outputFile

	// Run gosec
	err = cmd.Run()
	if err != nil && err.Error() != "exit status 1" {
		return "", fmt.Errorf("gosec failed: %w", err)
	}

	// Read the contents of the gosec output file
	outputBytes, err := os.ReadFile(gosecOutputFile)
	if err != nil {
		return "", fmt.Errorf("failed to read gosec output file: %w", err)
	}

	// Remove the gosec output file
	err = os.Remove(gosecOutputFile)
	if err != nil {
		fmt.Printf("Warning: failed to remove gosec output file: %v\n", err)
	}

	return string(outputBytes), nil
}

type OwnersFile struct {
	Approvers []string `yaml:"approvers"`
}

func readApprovers(repoPath string) ([]string, error) {
	ownersFilePath := filepath.Join(repoPath, ".github", "OWNERS")
	fileContent, err := os.ReadFile(ownersFilePath)
	if err != nil {
		return nil, err
	}

	var owners OwnersFile
	err = yaml.Unmarshal(fileContent, &owners)
	if err != nil {
		return nil, err
	}

	return owners.Approvers, nil
}

type GosecOutput struct {
	GolangErrors map[string]interface{} `json:"Golang errors"`
	Issues       []GosecIssue           `json:"Issues"`
	Stats        GosecStats             `json:"Stats"`
	GosecVersion string                 `json:"GosecVersion"`
}

type GosecIssue struct {
	Severity   string `json:"severity"`
	Confidence string `json:"confidence"`
	RuleID     string `json:"rule_id"`
	Details    string `json:"details"`
	File       string `json:"file"`
	Line       string `json:"line"`
	Author     string `json:"author"`
}

type GosecStats struct {
	Files int `json:"files"`
	Lines int `json:"lines"`
	Nosec int `json:"nosec"`
	Found int `json:"found"`
}

func parseGosecOutput(output string) (*GosecOutput, error) {
	// fmt.Println("Parsing gosec output...", output)
	var gosecOutput GosecOutput
	err := json.Unmarshal([]byte(output), &gosecOutput)
	if err != nil {
		return nil, err
	}
	return &gosecOutput, nil
}

func findLineAuthor(repoPath, file string, line int) (string, error) {
	cmd := exec.Command("git", "blame", "-L", fmt.Sprintf("%d,%d", line, line), "--", file)
	cmd.Dir = repoPath
	var out bytes.Buffer
	cmd.Stdout = &out
	err := cmd.Run()
	if err != nil {
		return "", fmt.Errorf("git blame failed: %w", err)
	}

	// Parse the output to extract the author's name
	// Adjust the parsing according to the output format of git blame
	output := out.String()
	// Example: "d1e5f7e7 (Author Name 2021-01-01 13:00:00 +0000 42) Code line here"
	re := regexp.MustCompile(`\((.*?)\d{4}-\d{2}-\d{2}`)
	matches := re.FindStringSubmatch(output)
	if len(matches) > 1 {
		return strings.TrimSpace(matches[1]), nil
	}
	return "", fmt.Errorf("author not found")
}
